"""
Dashboard Generator for Telegram channel reports.

This module reads the JSON reports generated by ChannelReporter and creates
interactive HTML dashboards using Plotly charts and existing Jinja2 templates.
"""

import json
import logging
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from jinja2 import Environment, FileSystemLoader
import pandas as pd
from datetime import datetime

from config import DEFAULT_GA_MEASUREMENT_ID


class ReportDashboardGenerator:
    """Generates interactive Plotly dashboards from channel reports."""
    
    def __init__(self, reports_dir: str, output_dir: str, template_dir: str):
        self.reports_dir = Path(reports_dir)
        self.output_dir = Path(output_dir)
        self.template_dir = Path(template_dir)
        self.logger = logging.getLogger(__name__)
        
        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up Jinja2 environment
        self._setup_jinja2()
        
        # Google Analytics ID
        self.ga_id = DEFAULT_GA_MEASUREMENT_ID
    
    def _setup_jinja2(self):
        """Set up Jinja2 environment with existing templates."""
        try:
            if self.template_dir.exists():
                self.env = Environment(loader=FileSystemLoader(str(self.template_dir)))
                self.logger.info(f"âœ… Jinja2 templates loaded from: {self.template_dir}")
            else:
                self.logger.error(f"Template directory not found: {self.template_dir}")
                raise FileNotFoundError(f"Template directory not found: {self.template_dir}")
        except Exception as e:
            self.logger.error(f"Error setting up Jinja2: {e}")
            raise
    
    def generate_all_dashboards(self, channels: List[str]) -> Dict[str, Any]:
        """Generate dashboards for all specified channels."""
        results = {}
        
        for channel in channels:
            try:
                self.logger.info(f"ðŸ”„ Generating dashboard for channel: {channel}")
                result = self.generate_channel_dashboard(channel)
                results[channel] = result
            except Exception as e:
                self.logger.error(f"Error generating dashboard for {channel}: {e}")
                results[channel] = {
                    'status': 'error',
                    'error': str(e)
                }
        
        # Generate index dashboard
        try:
            index_result = self.generate_index_dashboard(channels)
            results['_index'] = index_result
        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            results['_index'] = {
                'status': 'error',
                'error': str(e)
            }
        
        return results
    
    def generate_channel_dashboard(self, channel: str) -> Dict[str, Any]:
        """Generate dashboard for a specific channel."""
        try:
            # Load channel report
            report_file = self.reports_dir / channel / f"{channel}_report.json"
            if not report_file.exists():
                return {
                    'status': 'failed',
                    'error': f'Report file not found: {report_file}'
                }
            
            with open(report_file, 'r', encoding='utf-8') as f:
                report_data = json.load(f)
            
            # Generate Plotly charts
            charts = self._generate_channel_charts(report_data)
            
            # Render dashboard using our custom template
            template = self.env.get_template('dashboard_channel.html')
            
            # Prepare template context
            context = {
                'channel_name': channel,
                'ga_id': self.ga_id,
                'total_messages': report_data.get('data_summary', {}).get('total_messages', 0),
                'media_messages': report_data.get('message_statistics', {}).get('media_messages', 0),
                'text_messages': report_data.get('message_statistics', {}).get('text_only_messages', 0),
                'active_days': report_data.get('channel_info', {}).get('active_days', 0),
                'time_series_data': charts['time_series'],
                'media_pie_data': charts['media_pie'],
                'file_size_data': charts['file_size'],
                'hourly_data': charts['hourly'],
                'content_data': charts['content']
            }
            
            # Render HTML
            html_content = template.render(**context)
            
            # Save dashboard
            output_file = self.output_dir / f"{channel}_dashboard.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"âœ… Dashboard generated for {channel}: {output_file}")
            
            return {
                'status': 'success',
                'dashboard': {
                    'html_file': str(output_file),
                    'output_dir': str(self.output_dir),
                    'channel': channel
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating dashboard for {channel}: {e}")
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def generate_index_dashboard(self, channels: List[str]) -> Dict[str, Any]:
        """Generate index dashboard showing all channels."""
        try:
            # Collect channel information
            channel_info = []
            total_messages = 0
            total_storage_gb = 0
            date_ranges = []
            
            for channel in channels:
                try:
                    report_file = self.reports_dir / channel / f"{channel}_report.json"
                    if report_file.exists():
                        with open(report_file, 'r', encoding='utf-8') as f:
                            report_data = json.load(f)
                        
                        message_count = report_data.get('data_summary', {}).get('total_messages', 0)
                        total_messages += message_count
                        
                        # Estimate storage (simplified)
                        media_count = report_data.get('message_statistics', {}).get('media_messages', 0)
                        estimated_storage_mb = media_count * 5  # Assume 5MB average per media
                        total_storage_gb += estimated_storage_mb / 1024
                        
                        # Date range
                        if 'channel_info' in report_data:
                            start_date = report_data['channel_info'].get('first_message_date')
                            end_date = report_data['channel_info'].get('last_message_date')
                            if start_date and end_date:
                                date_ranges.append((start_date, end_date))
                        
                        channel_info.append({
                            'name': channel,
                            'message_count': message_count,
                            'html_file': f"{channel}_dashboard.html"
                        })
                except Exception as e:
                    self.logger.warning(f"Could not process {channel}: {e}")
            
            # Calculate overall date range
            date_range_days = 0
            if date_ranges:
                try:
                    start_dates = [datetime.fromisoformat(start.replace('Z', '+00:00')) for start, _ in date_ranges]
                    end_dates = [datetime.fromisoformat(end.replace('Z', '+00:00')) for _, end in date_ranges]
                    overall_start = min(start_dates)
                    overall_end = max(end_dates)
                    date_range_days = (overall_end - overall_start).days
                except:
                    pass
            
            # Generate overview chart
            overview_chart = self._generate_overview_chart(channel_info)
            
            # Render index dashboard using our custom template
            template = self.env.get_template('dashboard_index.html')
            
            context = {
                'ga_id': self.ga_id,
                'total_channels': len(channel_info),
                'total_messages': total_messages,
                'total_storage_gb': total_storage_gb,
                'date_range_days': date_range_days,
                'channels': channel_info,
                'channel_overview_data': overview_chart
            }
            
            html_content = template.render(**context)
            
            # Save index dashboard
            output_file = self.output_dir / "index.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"âœ… Index dashboard generated: {output_file}")
            
            return {
                'status': 'success',
                'dashboard': {
                    'html_file': str(output_file),
                    'output_dir': str(self.output_dir),
                    'type': 'index'
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def _generate_channel_charts(self, report_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Plotly charts for channel dashboard."""
        charts = {}
        
        try:
            # Time Series Chart
            if 'temporal_analysis' in report_data and 'error' not in report_data['temporal_analysis']:
                temp_data = report_data['temporal_analysis']
                if 'daily_activity' in temp_data:
                    daily_data = temp_data['daily_activity']
                    if isinstance(daily_data, list):
                        dates = [item['date'] for item in daily_data]
                        counts = [item['count'] for item in daily_data]
                        
                        charts['time_series'] = {
                            'data': [{
                                'x': dates,
                                'y': counts,
                                'type': 'scatter',
                                'mode': 'lines+markers',
                                'name': 'Daily Messages',
                                'line': {'color': '#3498db', 'width': 2},
                                'marker': {'size': 6}
                            }],
                            'layout': {
                                'title': 'Message Activity Over Time',
                                'xaxis': {'title': 'Date'},
                                'yaxis': {'title': 'Message Count'},
                                'height': 400,
                                'margin': {'l': 50, 'r': 50, 't': 50, 'b': 50}
                            }
                        }
            
            # Media Pie Chart
            if 'media_analysis' in report_data and 'error' not in report_data['media_analysis']:
                media_data = report_data['media_analysis']
                if 'media_distribution' in media_data:
                    media_dist = media_data['media_distribution']
                    if isinstance(media_dist, dict):
                        labels = list(media_dist.keys())
                        values = list(media_dist.values())
                        
                        charts['media_pie'] = {
                            'data': [{
                                'labels': labels,
                                'values': values,
                                'type': 'pie',
                                'hole': 0.4,
                                'marker': {'colors': ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']}
                            }],
                            'layout': {
                                'title': 'Media Type Distribution',
                                'height': 400,
                                'margin': {'l': 50, 'r': 50, 't': 50, 'b': 50}
                            }
                        }
            
            # File Size Histogram
            if 'media_analysis' in report_data and 'error' not in report_data['media_analysis']:
                media_data = report_data['media_analysis']
                if 'file_size_statistics' in media_data:
                    file_stats = media_data['file_size_statistics']
                    if file_stats:
                        # Create sample data for histogram (since we don't have individual file sizes)
                        mean_size = file_stats.get('mean_mb', 5)
                        std_size = file_stats.get('std_mb', 2)
                        
                        import numpy as np
                        sample_sizes = np.random.normal(mean_size, std_size, 1000)
                        sample_sizes = np.clip(sample_sizes, 0, mean_size * 3)  # Clip outliers
                        
                        charts['file_size'] = {
                            'data': [{
                                'x': sample_sizes,
                                'type': 'histogram',
                                'nbinsx': 20,
                                'name': 'File Sizes',
                                'marker': {'color': '#2ecc71', 'line': {'color': 'white', 'width': 1}}
                            }],
                            'layout': {
                                'title': 'File Size Distribution',
                                'xaxis': {'title': 'File Size (MB)'},
                                'yaxis': {'title': 'Count'},
                                'height': 400,
                                'margin': {'l': 50, 'r': 50, 't': 50, 'b': 50}
                            }
                        }
            
            # Hourly Activity Chart
            if 'temporal_analysis' in report_data and 'error' not in report_data['temporal_analysis']:
                temp_data = report_data['temporal_analysis']
                if 'hourly_activity' in temp_data:
                    hourly_data = temp_data['hourly_activity']
                    if isinstance(hourly_data, list):
                        hours = [item['hour'] for item in hourly_data]
                        counts = [item['count'] for item in hourly_data]
                        
                        charts['hourly'] = {
                            'data': [{
                                'x': hours,
                                'y': counts,
                                'type': 'bar',
                                'name': 'Hourly Activity',
                                'marker': {'color': '#e74c3c'}
                            }],
                            'layout': {
                                'title': 'Hourly Activity Pattern',
                                'xaxis': {'title': 'Hour of Day', 'tickmode': 'linear', 'tick0': 0, 'dtick': 6},
                                'yaxis': {'title': 'Message Count'},
                                'height': 400,
                                'margin': {'l': 50, 'r': 50, 't': 50, 'b': 50}
                            }
                        }
            
            # Content Analysis Chart
            if 'content_analysis' in report_data and 'error' not in report_data['content_analysis']:
                content_data = report_data['content_analysis']
                if 'content_categories' in content_data:
                    categories = content_data['content_categories']
                    if isinstance(categories, dict):
                        labels = list(categories.keys())
                        values = list(categories.values())
                        
                        charts['content'] = {
                            'data': [{
                                'x': labels,
                                'y': values,
                                'type': 'bar',
                                'name': 'Content Categories',
                                'marker': {'color': '#9b59b6'}
                            }],
                            'layout': {
                                'title': 'Content Length Categories',
                                'xaxis': {'title': 'Category'},
                                'yaxis': {'title': 'Message Count'},
                                'height': 400,
                                'margin': {'l': 50, 'r': 50, 't': 50, 'b': 50}
                            }
                        }
            
        except Exception as e:
            self.logger.error(f"Error generating charts: {e}")
        
        return charts
    
    def _generate_overview_chart(self, channel_info: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate overview chart for index dashboard."""
        try:
            if not channel_info:
                return {'data': [], 'layout': {}}
            
            # Sort by message count
            sorted_channels = sorted(channel_info, key=lambda x: x['message_count'], reverse=True)
            
            names = [ch['name'] for ch in sorted_channels]
            counts = [ch['message_count'] for ch in sorted_channels]
            
            return {
                'data': [{
                    'x': names,
                    'y': counts,
                    'type': 'bar',
                    'name': 'Message Count',
                    'marker': {'color': '#3498db'}
                }],
                'layout': {
                    'title': 'Channel Message Distribution',
                    'xaxis': {'title': 'Channel'},
                    'yaxis': {'title': 'Message Count'},
                    'height': 500,
                    'margin': {'l': 50, 'r': 50, 't': 50, 'b': 100},
                    'xaxis_tickangle': -45
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating overview chart: {e}")
            return {'data': [], 'layout': {}}
