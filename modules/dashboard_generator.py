"""
Dashboard Generator for Telegram channel reports.

This module reads the JSON reports generated by ChannelReporter and creates
interactive HTML dashboards using Plotly charts and existing Jinja2 templates.
"""

import json
import logging
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from jinja2 import Environment, FileSystemLoader
import pandas as pd
from datetime import datetime

from config import DEFAULT_GA_MEASUREMENT_ID


class ReportDashboardGenerator:
    """Generates interactive Plotly dashboards from channel reports."""
    
    def __init__(self, reports_dir: str, output_dir: str, template_dir: str):
        self.reports_dir = Path(reports_dir)
        self.output_dir = Path(output_dir)
        self.template_dir = Path(template_dir)
        self.logger = logging.getLogger(__name__)
        
        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up Jinja2 environment
        self._setup_jinja2()
        
        # Google Analytics ID
        self.ga_id = DEFAULT_GA_MEASUREMENT_ID
    
    def _setup_jinja2(self):
        """Set up Jinja2 environment with existing templates."""
        try:
            if self.template_dir.exists():
                self.env = Environment(loader=FileSystemLoader(str(self.template_dir)))
                self.logger.info(f"✅ Jinja2 templates loaded from: {self.template_dir}")
            else:
                self.logger.error(f"Template directory not found: {self.template_dir}")
                raise FileNotFoundError(f"Template directory not found: {self.template_dir}")
        except Exception as e:
            self.logger.error(f"Error setting up Jinja2: {e}")
            raise
    
    def generate_all_dashboards(self, channels: List[str]) -> Dict[str, Any]:
        """Generate dashboards for all specified channels."""
        results = {}
        
        for channel in channels:
            try:
                self.logger.info(f"🔄 Generating dashboard for channel: {channel}")
                result = self.generate_channel_dashboard(channel)
                results[channel] = result
            except Exception as e:
                self.logger.error(f"Error generating dashboard for {channel}: {e}")
                results[channel] = {
                    'status': 'error',
                    'error': str(e)
                }
        
        # Generate index dashboard
        try:
            index_result = self.generate_index_dashboard(channels)
            results['_index'] = index_result
        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            results['_index'] = {
                'status': 'error',
                'error': str(e)
            }
        
        return results
    
    def generate_channel_dashboard(self, channel: str) -> Dict[str, Any]:
        """Generate dashboard for a specific channel."""
        try:
            # Strip @ symbol from channel name for file paths
            channel_clean = channel.lstrip('@')
            
            # Load channel report
            report_file = self.reports_dir / channel_clean / f"{channel_clean}_report.json"
            if not report_file.exists():
                return {
                    'status': 'failed',
                    'error': f'Report file not found: {report_file}'
                }
            
            with open(report_file, 'r', encoding='utf-8') as f:
                report_data = json.load(f)
            
            # Generate Plotly charts
            charts = self._generate_channel_charts(report_data)
            
            # Render dashboard using our custom template
            template = self.env.get_template('dashboard_channel.html')
            
            # Prepare template context with fallbacks for missing data
            context = {
                'channel_name': channel,
                'ga_id': self.ga_id,
                'total_messages': report_data.get('data_summary', {}).get('total_messages', 0),
                'media_messages': report_data.get('data_summary', {}).get('media_messages', 0),
                'text_messages': report_data.get('data_summary', {}).get('text_messages', 0),
                'active_days': report_data.get('data_summary', {}).get('active_days', 0),
                'time_series_data': charts.get('time_series', None),
                'media_pie_data': charts.get('media_pie', None),
                'file_size_data': charts.get('file_size', None),
                'hourly_data': charts.get('hourly', None),
                'content_data': charts.get('content', None),
                'media_types_data': charts.get('media_types', None),
                'basic_stats': charts.get('basic_stats', None)
            }
            
            # Render HTML
            html_content = template.render(**context)
            
            # Save dashboard
            output_file = self.output_dir / f"{channel_clean}_dashboard.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"✅ Dashboard generated for {channel}: {output_file}")
            
            return {
                'status': 'success',
                'dashboard': {
                    'html_file': str(output_file),
                    'output_dir': str(self.output_dir),
                    'channel': channel
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating dashboard for {channel}: {e}")
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def generate_index_dashboard(self, channels: List[str]) -> Dict[str, Any]:
        """Generate index dashboard showing all channels."""
        try:
            # Collect channel information
            channel_info = []
            total_messages = 0
            total_storage_gb = 0
            date_ranges = []
            
            for channel in channels:
                try:
                    # Strip @ symbol from channel name for file paths
                    channel_clean = channel.lstrip('@')
                    
                    report_file = self.reports_dir / channel_clean / f"{channel_clean}_report.json"
                    if report_file.exists():
                        with open(report_file, 'r', encoding='utf-8') as f:
                            report_data = json.load(f)
                        
                        message_count = report_data.get('data_summary', {}).get('total_messages', 0)
                        total_messages += message_count
                        
                        # Get storage info from file_analysis if available
                        if 'file_analysis' in report_data:
                            total_size_mb = report_data['file_analysis'].get('total_size_mb', 0)
                            total_storage_gb += total_size_mb / 1024
                        else:
                            # Fallback: estimate storage from media messages
                            media_count = report_data.get('data_summary', {}).get('media_messages', 0)
                            estimated_storage_mb = media_count * 5  # Assume 5MB average per media
                            total_storage_gb += estimated_storage_mb / 1024
                        
                        channel_info.append({
                            'name': channel,
                            'message_count': message_count,
                            'html_file': f"{channel_clean}_dashboard.html"
                        })
                        
                        self.logger.debug(f"✅ Processed {channel}: {message_count} messages")
                    else:
                        self.logger.warning(f"⚠️  Report file not found for {channel}: {report_file}")
                        
                except Exception as e:
                    self.logger.warning(f"⚠️  Could not process {channel}: {e}")
                    continue
            
            # Generate overview chart
            overview_chart = self._generate_overview_chart(channel_info)
            
            # Render index dashboard using our custom template
            template = self.env.get_template('dashboard_index.html')
            
            context = {
                'ga_id': self.ga_id,
                'total_channels': len(channel_info),
                'total_messages': total_messages,
                'total_storage_gb': round(total_storage_gb, 2),
                'channels': channel_info,
                'channel_overview_data': overview_chart
            }
            
            html_content = template.render(**context)
            
            # Save index dashboard
            output_file = self.output_dir / "index.html"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"✅ Index dashboard generated: {output_file}")
            
            return {
                'status': 'success',
                'dashboard': {
                    'html_file': str(output_file),
                    'output_dir': str(self.output_dir),
                    'type': 'index'
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def _generate_channel_charts(self, report_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate Plotly charts for channel dashboard."""
        charts = {}
        
        try:
            # Basic statistics charts
            data_summary = report_data.get('data_summary', {})
            
            # Message type distribution (pie chart)
            if 'media_messages' in data_summary and 'text_messages' in data_summary:
                media_count = data_summary.get('media_messages', 0)
                text_count = data_summary.get('text_messages', 0)
                
                if media_count > 0 or text_count > 0:
                    charts['media_pie'] = {
                        'labels': ['Media Messages', 'Text Messages'],
                        'values': [media_count, text_count],
                        'type': 'pie'
                    }
            
            # Media types distribution
            if 'media_types' in report_data and report_data['media_types']:
                media_types = report_data['media_types']
                if isinstance(media_types, dict) and media_types:
                    charts['media_types'] = {
                        'labels': list(media_types.keys()),
                        'values': list(media_types.values()),
                        'type': 'bar'
                    }
            
            # File size analysis
            if 'file_analysis' in report_data:
                file_analysis = report_data['file_analysis']
                total_size = file_analysis.get('total_size_mb', 0)
                avg_size = file_analysis.get('average_size_mb', 0)
                
                if total_size > 0:
                    charts['file_size'] = {
                        'total_size_mb': total_size,
                        'average_size_mb': avg_size,
                        'type': 'stats'
                    }
            
            # Generate default charts if none were created
            if not charts:
                charts = self._generate_default_charts(data_summary)
            
            return charts
            
        except Exception as e:
            self.logger.warning(f"⚠️  Error generating charts: {e}")
            return self._generate_default_charts(data_summary)
    
    def _generate_default_charts(self, data_summary: Dict[str, Any]) -> Dict[str, Any]:
        """Generate default charts when detailed analysis is not available."""
        charts = {}
        
        try:
            # Simple message count chart
            total_messages = data_summary.get('total_messages', 0)
            if total_messages > 0:
                charts['basic_stats'] = {
                    'total_messages': total_messages,
                    'type': 'stats'
                }
            
            # Media vs text distribution (if available)
            media_messages = data_summary.get('media_messages', 0)
            text_messages = data_summary.get('text_messages', 0)
            
            if media_messages > 0 or text_messages > 0:
                charts['message_distribution'] = {
                    'labels': ['Media', 'Text'],
                    'values': [media_messages, text_messages],
                    'type': 'pie'
                }
            
        except Exception as e:
            self.logger.warning(f"⚠️  Error generating default charts: {e}")
        
        return charts
    
    def _generate_overview_chart(self, channel_info: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate overview chart for index dashboard."""
        try:
            if not channel_info:
                return {'data': [], 'layout': {}}
            
            # Sort by message count
            sorted_channels = sorted(channel_info, key=lambda x: x['message_count'], reverse=True)
            
            names = [ch['name'] for ch in sorted_channels]
            counts = [ch['message_count'] for ch in sorted_channels]
            
            return {
                'data': [{
                    'x': names,
                    'y': counts,
                    'type': 'bar',
                    'name': 'Message Count',
                    'marker': {'color': '#3498db'}
                }],
                'layout': {
                    'title': 'Channel Message Distribution',
                    'xaxis': {'title': 'Channel'},
                    'yaxis': {'title': 'Message Count'},
                    'height': 500,
                    'margin': {'l': 50, 'r': 50, 't': 50, 'b': 100},
                    'xaxis_tickangle': -45
                }
            }
            
        except Exception as e:
            self.logger.error(f"Error generating overview chart: {e}")
            return {'data': [], 'layout': {}}
