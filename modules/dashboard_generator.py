"""
Dashboard Generator for Telegram channel reports.

This module reads the JSON reports generated by ChannelReporter and creates
interactive HTML dashboards using Plotly charts and existing Jinja2 templates.
"""

import json
import logging
from pathlib import Path
from typing import Any

import pandas as pd
from jinja2 import Environment, FileSystemLoader

from config import (
    DEFAULT_GA_MEASUREMENT_ID,
    REPORT_FILE_PATTERN,
    DASHBOARD_FILE_PATTERN,
)


class ReportDashboardGenerator:
    """Generates interactive Plotly dashboards from channel reports."""

    def __init__(self, reports_dir: str, output_dir: str, template_dir: str):
        self.reports_dir = Path(reports_dir)
        self.output_dir = Path(output_dir)
        self.template_dir = Path(template_dir)
        self.logger = logging.getLogger(__name__)

        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Set up Jinja2 environment
        self._setup_jinja2()

        # Google Analytics ID
        self.ga_id = DEFAULT_GA_MEASUREMENT_ID

    def _setup_jinja2(self):
        """Set up Jinja2 environment with existing templates."""
        try:
            if self.template_dir.exists():
                self.env = Environment(loader=FileSystemLoader(str(self.template_dir)))
                self.logger.info(
                    f"âœ… Jinja2 templates loaded from: {self.template_dir}"
                )
            else:
                self.logger.error(f"Template directory not found: {self.template_dir}")
                raise FileNotFoundError(
                    f"Template directory not found: {self.template_dir}"
                )
        except Exception as e:
            self.logger.error(f"Error setting up Jinja2: {e}")
            raise

    def _load_json_with_pandas(self, file_path: Path) -> dict[str, Any]:
        """Load JSON file using pandas with fallback to json module."""
        try:
            # Try pandas first - handles various JSON formats better
            df = pd.read_json(file_path)

            # Handle different pandas output formats
            if isinstance(df, pd.DataFrame):
                if df.empty:
                    self.logger.warning(f"Empty DataFrame from: {file_path}")
                    return {}

                # Convert DataFrame to records and normalize structure
                records = df.to_dict("records")
                data = {
                    "data_summary": {"total_messages": len(records)},
                    "messages": records,
                }
                self.logger.info(
                    f"âœ… Pandas JSON loaded: {len(records)} records from {file_path}"
                )
                return self._normalize_json_structure(data)
            else:
                # If pandas returns something else, try to convert to dict
                if hasattr(df, "to_dict"):
                    data = df.to_dict()
                else:
                    data = df
                self.logger.info(
                    f"âœ… Pandas JSON loaded: {type(data).__name__} from {file_path}"
                )
                return data if isinstance(data, dict) else {"data": data}

        except Exception as e:
            self.logger.warning(
                "âš ï¸  PANDAS JSON LOADING FAILED - Falling back to json module"
            )
            self.logger.warning(f"   ðŸ“ File: {file_path}")
            self.logger.warning(f"   ðŸ¼ Pandas Error: {e}")
            self.logger.warning("   ðŸ”„ Attempting fallback to json module...")

            # Fallback to original json method
            try:
                with open(file_path, encoding="utf-8") as f:
                    data = json.load(f)
                self.logger.warning(
                    "âš ï¸  FALLBACK SUCCESSFUL - Using json module instead of pandas"
                )
                self.logger.warning(f"   ðŸ“Š Data type: {type(data).__name__}")
                self.logger.warning(
                    f"   ðŸ“ File size: {file_path.stat().st_size / 1024:.2f} KB"
                )
                self.logger.warning(
                    "   ðŸ’¡ Consider: Check JSON structure or file format"
                )
                return data
            except Exception as json_error:
                self.logger.error(
                    "âŒ BOTH METHODS FAILED - Pandas and json module both failed"
                )
                self.logger.error(f"   ðŸ“ File: {file_path}")
                self.logger.error(f"   ðŸ¼ Pandas Error: {e}")
                self.logger.error(f"   ðŸ“„ JSON Error: {json_error}")
                self.logger.error(
                    "   ðŸš¨ File may be corrupted or have invalid JSON format"
                )
                raise

    def _normalize_json_structure(self, data: Any) -> dict[str, Any]:
        """Normalize various JSON structures to expected format."""
        if isinstance(data, dict):
            # Already in dict format, check if it has expected structure
            if "data_summary" in data:
                return data
            elif "messages" in data:
                # Wrap in expected structure
                return {
                    "data_summary": {"total_messages": len(data["messages"])},
                    "messages": data["messages"],
                }
            else:
                # Try to infer structure
                return {"data_summary": {"total_messages": 1}, "raw_data": data}
        elif isinstance(data, list):
            # List of messages or records
            return {"data_summary": {"total_messages": len(data)}, "messages": data}
        else:
            # Single value or other type
            return {"data_summary": {"total_messages": 1}, "data": data}

    def _analyze_json_structure(self, file_path: Path) -> dict[str, Any]:
        """Analyze JSON file structure to identify potential pandas compatibility issues."""
        try:
            with open(file_path, encoding="utf-8") as f:
                data = json.load(f)

            analysis = {
                "file_size_kb": file_path.stat().st_size / 1024,
                "data_type": type(data).__name__,
                "structure": "unknown",
                "warnings": [],
                "recommendations": [],
            }

            if isinstance(data, dict):
                analysis["structure"] = "dictionary"
                analysis["keys"] = list(data.keys())

                # Check for mixed data types that might cause pandas issues
                has_lists = any(isinstance(v, list) for v in data.values())
                has_dicts = any(isinstance(v, dict) for v in data.values())
                has_scalars = any(
                    not isinstance(v, (list, dict)) for v in data.values()
                )

                if has_lists and has_dicts and has_scalars:
                    analysis["warnings"].append(
                        "Mixed data types detected - may cause pandas compatibility issues"
                    )
                    analysis["recommendations"].append(
                        "Consider restructuring JSON to separate lists and metadata"
                    )

                if "messages" in data and isinstance(data["messages"], list):
                    analysis["messages_count"] = len(data["messages"])
                    if len(data["messages"]) > 0:
                        sample_message = data["messages"][0]
                        analysis["message_keys"] = (
                            list(sample_message.keys())
                            if isinstance(sample_message, dict)
                            else []
                        )

            elif isinstance(data, list):
                analysis["structure"] = "list"
                analysis["list_length"] = len(data)
                if len(data) > 0:
                    sample_item = data[0]
                    analysis["item_type"] = type(sample_item).__name__
                    if isinstance(sample_item, dict):
                        analysis["item_keys"] = list(sample_item.keys())

            return analysis

        except Exception as e:
            return {
                "error": str(e),
                "file_size_kb": file_path.stat().st_size / 1024
                if file_path.exists()
                else 0,
            }

    def generate_all_dashboards(self, channels: list[str]) -> dict[str, Any]:
        """Generate dashboards for all specified channels."""
        results = {}

        for channel in channels:
            try:
                self.logger.info(f"ðŸ”„ Generating dashboard for channel: {channel}")
                result = self.generate_channel_dashboard(channel)
                results[channel] = result
            except Exception as e:
                self.logger.error(f"Error generating dashboard for {channel}: {e}")
                results[channel] = {"status": "error", "error": str(e)}

        # Generate index dashboard
        try:
            index_result = self.generate_index_dashboard(channels)
            results["_index"] = index_result
        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            results["_index"] = {"status": "error", "error": str(e)}

        return results

    def generate_channel_dashboard(self, channel: str) -> dict[str, Any]:
        """Generate dashboard for a specific channel."""
        try:
            # Strip @ symbol from channel name for file paths
            channel_clean = channel.lstrip("@")

            # Load channel report
            report_file = (
                self.reports_dir / channel_clean / REPORT_FILE_PATTERN.format(channel=channel_clean)
            )
            if not report_file.exists():
                return {
                    "status": "failed",
                    "error": f"Report file not found: {report_file}",
                }

            # Use the new pandas-based JSON loading method
            report_data = self._load_json_with_pandas(report_file)

            # Generate Plotly charts
            charts = self._generate_channel_charts(report_data)

            # Render dashboard using our custom template
            template = self.env.get_template("dashboard_channel.html")

            # Prepare template context with fallbacks for missing data
            context = {
                "channel_name": channel,
                "ga_id": self.ga_id,
                "total_messages": report_data.get("data_summary", {}).get(
                    "total_messages", 0
                ),
                "media_messages": report_data.get("data_summary", {}).get(
                    "media_messages", 0
                ),
                "text_messages": report_data.get("data_summary", {}).get(
                    "text_messages", 0
                ),
                "active_days": report_data.get("data_summary", {}).get(
                    "active_days", 0
                ),
                "time_series_data": charts.get("time_series", None),
                "media_pie_data": charts.get("media_pie", None),
                "file_size_data": charts.get("file_size", None),
                "hourly_data": charts.get("hourly", None),
                "content_data": charts.get("content", None),
                "media_types_data": charts.get("media_types", None),
                "basic_stats": charts.get("basic_stats", None),
            }

            # Render HTML
            html_content = template.render(**context)

            # Save dashboard
            output_file = self.output_dir / DASHBOARD_FILE_PATTERN.format(channel=channel_clean)
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(html_content)

            self.logger.info(f"âœ… Dashboard generated for {channel}: {output_file}")

            return {
                "status": "success",
                "dashboard": {
                    "html_file": str(output_file),
                    "output_dir": str(self.output_dir),
                    "channel": channel,
                },
            }

        except Exception as e:
            self.logger.error(f"Error generating dashboard for {channel}: {e}")
            return {"status": "error", "error": str(e)}

    def generate_index_dashboard(self, channels: list[str]) -> dict[str, Any]:
        """Generate index dashboard showing all channels."""
        try:
            # Collect channel information
            channel_info = []
            total_messages = 0
            total_storage_gb = 0
            date_ranges = []

            for channel in channels:
                try:
                    # Strip @ symbol from channel name for file paths
                    channel_clean = channel.lstrip("@")

                    report_file = (
                        self.reports_dir
                        / channel_clean
                        / REPORT_FILE_PATTERN.format(channel=channel_clean)
                    )
                    if report_file.exists():
                        with open(report_file, encoding="utf-8") as f:
                            report_data = json.load(f)

                        message_count = report_data.get("data_summary", {}).get(
                            "total_messages", 0
                        )
                        total_messages += message_count

                        # Get storage info from file_analysis if available
                        if "file_analysis" in report_data:
                            total_size_mb = report_data["file_analysis"].get(
                                "total_size_mb", 0
                            )
                            total_storage_gb += total_size_mb / 1024
                        else:
                            # Fallback: estimate storage from media messages
                            media_count = report_data.get("data_summary", {}).get(
                                "media_messages", 0
                            )
                            estimated_storage_mb = (
                                media_count * 5
                            )  # Assume 5MB average per media
                            total_storage_gb += estimated_storage_mb / 1024

                        channel_info.append(
                            {
                                "name": channel,
                                "message_count": message_count,
                                "html_file": f"{channel_clean}_dashboard.html",
                            }
                        )

                        self.logger.debug(
                            f"âœ… Processed {channel}: {message_count} messages"
                        )
                    else:
                        self.logger.warning(
                            f"âš ï¸  Report file not found for {channel}: {report_file}"
                        )

                except Exception as e:
                    self.logger.warning(f"âš ï¸  Could not process {channel}: {e}")
                    continue

            # Generate overview chart
            overview_chart = self._generate_overview_chart(channel_info)

            # Render index dashboard using our custom template
            template = self.env.get_template("dashboard_index.html")

            context = {
                "ga_id": self.ga_id,
                "total_channels": len(channel_info),
                "total_messages": total_messages,
                "total_storage_gb": round(total_storage_gb, 2),
                "channels": channel_info,
                "channel_overview_data": overview_chart,
            }

            html_content = template.render(**context)

            # Save index dashboard
            output_file = self.output_dir / "index.html"
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(html_content)

            self.logger.info(f"âœ… Index dashboard generated: {output_file}")

            return {
                "status": "success",
                "dashboard": {
                    "html_file": str(output_file),
                    "output_dir": str(self.output_dir),
                    "type": "index",
                },
            }

        except Exception as e:
            self.logger.error(f"Error generating index dashboard: {e}")
            return {"status": "error", "error": str(e)}

    def _generate_channel_charts(self, report_data: dict[str, Any]) -> dict[str, Any]:
        """Generate Plotly charts for channel dashboard."""
        charts = {}

        try:
            # Basic statistics charts
            data_summary = report_data.get("data_summary", {})

            # Message type distribution (pie chart)
            if "media_messages" in data_summary and "text_messages" in data_summary:
                media_count = data_summary.get("media_messages", 0)
                text_count = data_summary.get("text_messages", 0)

                if media_count > 0 or text_count > 0:
                    charts["media_pie"] = {
                        "labels": ["Media Messages", "Text Messages"],
                        "values": [media_count, text_count],
                        "type": "pie",
                    }

            # Media types distribution
            if report_data.get("media_types"):
                media_types = report_data["media_types"]
                if isinstance(media_types, dict) and media_types:
                    charts["media_types"] = {
                        "labels": list(media_types.keys()),
                        "values": list(media_types.values()),
                        "type": "bar",
                    }

            # File size analysis
            if "file_analysis" in report_data:
                file_analysis = report_data["file_analysis"]
                total_size = file_analysis.get("total_size_mb", 0)
                avg_size = file_analysis.get("average_size_mb", 0)

                if total_size > 0:
                    charts["file_size"] = {
                        "total_size_mb": total_size,
                        "average_size_mb": avg_size,
                        "type": "stats",
                    }

            # Generate default charts if none were created
            if not charts:
                charts = self._generate_default_charts(data_summary)

            return charts

        except Exception as e:
            self.logger.warning(f"âš ï¸  Error generating charts: {e}")
            return self._generate_default_charts(data_summary)

    def _generate_default_charts(self, data_summary: dict[str, Any]) -> dict[str, Any]:
        """Generate default charts when detailed analysis is not available."""
        charts = {}

        try:
            # Simple message count chart
            total_messages = data_summary.get("total_messages", 0)
            if total_messages > 0:
                charts["basic_stats"] = {
                    "total_messages": total_messages,
                    "type": "stats",
                }

            # Media vs text distribution (if available)
            media_messages = data_summary.get("media_messages", 0)
            text_messages = data_summary.get("text_messages", 0)

            if media_messages > 0 or text_messages > 0:
                charts["message_distribution"] = {
                    "labels": ["Media", "Text"],
                    "values": [media_messages, text_messages],
                    "type": "pie",
                }

        except Exception as e:
            self.logger.warning(f"âš ï¸  Error generating default charts: {e}")

        return charts

    def _generate_overview_chart(
        self, channel_info: list[dict[str, Any]]
    ) -> dict[str, Any]:
        """Generate overview chart for index dashboard."""
        try:
            if not channel_info:
                return {"data": [], "layout": {}}

            # Sort by message count
            sorted_channels = sorted(
                channel_info, key=lambda x: x["message_count"], reverse=True
            )

            names = [ch["name"] for ch in sorted_channels]
            counts = [ch["message_count"] for ch in sorted_channels]

            return {
                "data": [
                    {
                        "x": names,
                        "y": counts,
                        "type": "bar",
                        "name": "Message Count",
                        "marker": {"color": "#3498db"},
                    }
                ],
                "layout": {
                    "title": "Channel Message Distribution",
                    "xaxis": {"title": "Channel"},
                    "yaxis": {"title": "Message Count"},
                    "height": 500,
                    "margin": {"l": 50, "r": 50, "t": 50, "b": 100},
                    "xaxis_tickangle": -45,
                },
            }

        except Exception as e:
            self.logger.error(f"Error generating overview chart: {e}")
            return {"data": [], "layout": {}}
